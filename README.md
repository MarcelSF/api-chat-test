# README

Chatbot API for Lytt. An exercise in RESTful API, Rspec testing and cloud implementation.

Ruby version 2.4.4
Rails version 5.2.3

Why Rails?

I chose Ruby on Rails as my framework because it allows me to create a solid API in a time-effective way, as well as test it. The robust gem library available to ruby also gave me access to very efficient tools for testing the API as well as ensuring the security of the data being sent back to the front-end.

This could be done in microservices with the Serverless Framework (Node.JS and React), but it would have taken more than double the time since it requires a lot more setup work when compared to Rails just to get equivalent results. Furthermore, Rails is the framework I am most comfortable with.

* SETUP: After cloning the repository, just run 'bundle install', create and migrate the database (rails db:create db:migrate) and run 'rails s'. The API should be available in localhost:3000

* CLOUD DELIVERY

All of these endpoints can also be found on a Heroku app on:

https://lytt-api-test.herokuapp.com/api/v1

I chose heroku for it's simplicity of configuration, although I do understand that in terms of scaling it is not the best option due to pricing. However, for initial releases of an app, it is a reliable and very practical cloud platform.

* Important Gems:

 This API uses the Compact Language Detection (CLD) for Ruby gem. It can quickly identify the language of a string and I used it to return the correct language code for my Message models.

 I also used Active Model Serializers to more easily determine which information would be available in the endpoints. Should, in the future, more sensitive data be added to Messages or Replies, we can easily determine what attributes should or shouldn't be sent to the front-end.

* Testing: Use 'bundle exec rspec' to run the test suite. It uses primarily Rspec, database_cleaner and factory_bot. I decided to test the model validations and the endpoints primarily. More testing could be implemented, specially after a front-end implementation.

* Endpoints:

 This API has 3 main endpoints and associated error messages:

#1 - Receive: a text message from a reporting person (user) in any language then Detect Language: German, English and Spanish language only. Any other language will make the API respond with a programmed 422 status error message: "Unfortunately we don't have support for your language yet."

Endpoint:

 POST localhost:3000/api/v1/sessions/session_id/messages

Each message will be saved with timestamps, a detected language code and a unique random identifier generated by the API. For security reasons, the text is saved as an empty string ("").

#2 - Allow retrieving a message information by using its unique identifier. Each message has a unique identifier. If you have its session ID and identifier, you can access the message. Otherwise, you'll see a 404 status error with the message: "Resource doesn't exist"

Endpoint:

  GET localhost:3000/api/v1/sessions/session_id/messages/identifier

#3 - Reply/Fetch Automated Replies: with the correct "Reply" for every user message, in the correct user session and order. The messages are displayed in a DESCENDING order (newest to oldest). This endpoint will return an array with all the replies associated to that session, provided you have its ID.

Endpoint:

GET localhost:3000/api/v1/sessions/session_id/replies




* Using the endpoints

  To test the API, I sugest using a software called Postman. It manages to create HTTP requests quite easily, and is free.

* Configuration

This API uses Postgresql database. Redis and CORS are also setup for future ACTION CABLE implementation with a React front-end app. The Action Cable channels have already been created as well.

* Database creation

 rails db:create db:migrate should be enough to setup the Database.

* How to run the test suite

Simply run 'bundle exec rspec' to run the test suite. It focuses mainly on the models and the endpoints themselves, testing the correct responses for each available endpoint.

* Services (job queues, cache servers, search engines etc.)

Action Cable is enabled for future implementation of Web Sockets and Front-End integration, as well as Redis and CORS.

* NEXT STEPS

The next step would be to create a React App for the front-end which would, in turn, be able to show, in real time, both messages and replies to the user. Another important step would be to implement the User model and authentication with Devise (already in gem file). To improve performance,  maybe create a side job with sidekiq to handle all the replies generated for each message.

Another part that should be polished is the error handling part of the API. At the moment, a lot of the code repeats itself, so a little bit of refactoring would make the code more elegant. Also, the app does not yet cover other 404 errors, such as when the user tries to access an endpoint that does not exist. The same goes for the testing suite, which should cover more parts of the API such as the controllers.

